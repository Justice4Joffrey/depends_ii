use std::cell::Ref;
use std::{
    collections::HashSet,
    hash::{Hash, Hasher},
    rc::Rc,
};

use depends::{
    derives::{Dependencies, Operation, Value},
    error::EarlyExit,
    graphviz::GraphvizVisitor,
    DepRef, DepRef2, DepRef3, Dependencies2, Dependencies3, Dependency, DerivedNode,
    HashSetVisitor, HashValue, InputNode, IsDirty, NodeHash, NodeState, Resolve, SingleRef,
    TargetMut, UpdateDerived, UpdateInput,
};

pub trait NumberLike {
    fn value(&self) -> i32;
}

/// A unit of data within a graph.
#[derive(Value, Default, Hash)]
pub struct NumberValueI32 {
    pub value: i32,
}

impl NumberValueI32 {
    pub fn new(value: i32) -> Self {
        Self { value }
    }
}

impl NumberLike for NumberValueI32 {
    fn value(&self) -> i32 {
        self.value
    }
}

// By implementing UpdateInput, we can change the value of this node from
// outside of the graph.
impl UpdateInput for NumberValueI32 {
    type Update = i32;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

/// Another unit of data within a graph, just to demonstrate we can combine
/// arbitrary types, so long as we know how to translate the output of one to
/// the input of another.
#[derive(Value, Default, Hash)]
pub struct NumberValueI8 {
    pub value: i8,
}

impl NumberValueI8 {
    pub fn new(value: i8) -> Self {
        Self { value }
    }
}

impl NumberLike for Ref<'_, NodeState<NumberValueI8>> {
    fn value(&self) -> i32 {
        self.value as i32
    }
}
impl NumberLike for Ref<'_, NodeState<NumberValueI32>> {
    fn value(&self) -> i32 {
        self.value
    }
}

impl UpdateInput for NumberValueI8 {
    type Update = i8;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
// represents read-references to all of its fields.
pub struct Sum;

// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
// represents read-references to all of its fields.
impl<A: NumberLike, B: NumberLike> UpdateDerived<DepRef2<'_, A, B>, Sum> for NumberValueI32 {
    fn update(&mut self, value: DepRef2<'_, A, B>) -> Result<(), EarlyExit> {
        self.value = value.a.data().value() + value.b.data().value();
        Ok(())
    }
}

impl<A: NumberLike, B: NumberLike, C: NumberLike> UpdateDerived<DepRef3<'_, A, B, C>, Sum>
    for NumberValueI32
{
    fn update(&mut self, value: DepRef3<'_, A, B, C>) -> Result<(), EarlyExit> {
        self.value = value.a.data().value() + value.b.data().value() + value.c.data().value();
        Ok(())
    }
}

pub struct Square;
impl<A: NumberLike> UpdateDerived<DepRef<'_, A>, Square> for NumberValueI32 {
    fn update(&mut self, value: DepRef<'_, A>) -> Result<(), EarlyExit> {
        self.value = value.data().value().pow(2);
        Ok(())
    }
}

pub struct Multiply;
impl<A: NumberLike, B: NumberLike> UpdateDerived<DepRef2<'_, A, B>, Multiply> for NumberValueI32 {
    fn update(&mut self, value: DepRef2<'_, A, B>) -> Result<(), EarlyExit> {
        self.value = value.a.data().value() * value.b.data().value();
        Ok(())
    }
}

// (As imported in graph.rs)
#[allow(unused)]
fn main() {
    // Create some input nodes. These are nodes we can update from outside of
    // the graph.
    let a = InputNode::new(NumberValueI32::new(1));
    let b = InputNode::new(NumberValueI32::new(2));
    // Note that we can combine different types in the same graph.
    let c = InputNode::new(NumberValueI8::new(3));
    let d = InputNode::new(NumberValueI32::new(4));
    let e = InputNode::new(NumberValueI32::new(5));

    // Now for some derived nodes. We can't update these from outside of the
    // graph. They are updated when their dependencies change.

    // C squared
    let g = DerivedNode::new(
        Dependency::new(Rc::clone(&c)),
        Square,
        NumberValueI32::default(),
    );
    // Sum of a and b
    let h = DerivedNode::new(
        Dependencies2::new(Rc::clone(&a), Rc::clone(&b)),
        Sum,
        NumberValueI32::default(),
    );

    // Product of d and e
    let i = DerivedNode::new(
        Dependencies2::new(Rc::clone(&d), Rc::clone(&e)),
        Multiply,
        NumberValueI32::default(),
    );
    // Create another edge to node a
    let j = DerivedNode::new(
        Dependencies2::new(Rc::clone(&a), Rc::clone(&i)),
        Sum,
        NumberValueI32::default(),
    );

    // Finally, the sum of all of the above
    let answer = DerivedNode::new(
        Dependencies3::new(Rc::clone(&g), Rc::clone(&h), Rc::clone(&j)),
        Sum,
        NumberValueI32::default(),
    );

    // We can render the graph to Graphviz format
    // let mut visitor = GraphvizVisitor::new();
    // answer.resolve(&mut visitor).unwrap();
    // println!("{}", visitor.render().unwrap());

    // We can now resolve the graph. This will update all of the derived
    // nodes
    let mut visitor = HashSetVisitor::new();
    {
        // This can fail if there are cycles in the graph or an existing read
        // reference is being held.
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 1: {}", res.value);
        assert_eq!(res.value, (3_i32.pow(2)) + (1 + 2) + (1 + (4 * 5)));
    }
    {
        // If we update input nodes, any nodes which depend on them will be
        // re-resolved. Those which don't will return their cached value.
        a.update(10).unwrap();
        b.update(12).unwrap();
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 2: {}", res.value);
        assert_eq!(res.value, (3_i32.pow(2)) + (10 + 12) + (10 + (4 * 5)));
    }
    {
        // The graph contains multiple types whose edges are type-checked.
        // Therefore, only valid graphs can be constructed.
        c.update(5).unwrap();
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 3: {}", res.value);
        assert_eq!(res.value, (5_i32.pow(2)) + (10 + 12) + (10 + (4 * 5)));
    }
}

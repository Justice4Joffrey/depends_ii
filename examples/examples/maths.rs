use std::{
    collections::HashSet,
    hash::{Hash, Hasher},
    rc::Rc,
};
use std::cell::Ref;

use depends::{derives::{Dependencies, Operation, Value}, error::EarlyExit, graphviz::GraphvizVisitor, DepRef, DepRef2, DepRef3, Dependencies2, Dependencies3, Dependency, DerivedNode, HashValue, InputNode, NodeHash, Resolve, SingleRef, TargetMut, UpdateDerived, UpdateInput, NodeState, HashSetVisitor};

pub trait NumberLike {
    fn value(&self) -> i32;
}

/// A unit of data within a graph.
#[derive(Value, Default, Hash)]
pub struct NumberValueI32 {
    pub value: i32,
}

impl NumberValueI32 {
    pub fn new(value: i32) -> Self {
        Self { value }
    }
}

impl NumberLike for NumberValueI32 {
    fn value(&self) -> i32 {
        self.value
    }
}

// By implementing UpdateInput, we can change the value of this node from
// outside of the graph.
impl UpdateInput for NumberValueI32 {
    type Update = i32;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

/// Another unit of data within a graph, just to demonstrate we can combine
/// arbitrary types, so long as we know how to translate the output of one to
/// the input of another.
#[derive(Value, Default, Hash)]
pub struct NumberValueI8 {
    pub value: i8,
}

impl NumberValueI8 {
    pub fn new(value: i8) -> Self {
        Self { value }
    }
}

impl NumberLike for Ref<'_, NodeState<NumberValueI32>> {
    fn value(&self) -> i32 {
        self.value
    }
}

impl UpdateInput for NumberValueI8 {
    type Update = i8;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
// represents read-references to all of its fields.
pub struct Sum;

// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
// represents read-references to all of its fields.
impl<A, B> UpdateDerived<DepRef2<'_, A, B>, Sum> for NumberValueI32 {
    fn update(&mut self, value: DepRef2<'_, A, B>) -> Result<(), EarlyExit> {
        todo!()
    }
}

impl<A, B, C> UpdateDerived<DepRef3<'_, A, B, C>, Sum> for NumberValueI32 {
    fn update(&mut self, value: DepRef3<'_, A, B, C>) -> Result<(), EarlyExit> {
        todo!()
    }
}

pub struct Square;
impl<A: NumberLike> UpdateDerived<DepRef<'_, A>, Square> for NumberValueI32 {
    fn update(&mut self, value: DepRef<'_, A>) -> Result<(), EarlyExit> {
        self.value = value.data().value().pow(2);
        Ok(())
    }
}

pub struct Multiply;
impl<A, B> UpdateDerived<DepRef2<'_, A, B>, Multiply> for NumberValueI32 {
    fn update(&mut self, value: DepRef2<'_, A, B>) -> Result<(), EarlyExit> {
        todo!()
    }
}

// (As imported in graph.rs)
#[allow(unused)]
fn main() {
    // Create some input nodes. These are nodes we can update from outside of
    // the graph.
    let a = InputNode::new(NumberValueI32::new(100));
    let b = InputNode::new(NumberValueI32::new(2));
    // Note that we can combine different types in the same graph.
    let c = InputNode::new(NumberValueI8::new(3));
    let d = InputNode::new(NumberValueI32::new(4));
    let e = InputNode::new(NumberValueI32::new(5));

    // Now for some derived nodes. We can't update these from outside of the
    // graph. They are updated when their dependencies change.

    // C squared
    let g = DerivedNode::new(
        // Dependency::<Rc<InputNode<NumberValueI32>>>::new(Rc::clone(&a)),
        Dependency::new(Rc::clone(&a)),
        Square,
        NumberValueI32::default(),
    );
    // Sum of a and b
    // let h = DerivedNode::new(
    //     Dependencies2::<Rc<InputNode<NumberValueI32>>, Rc<InputNode<NumberValueI32>>>::new(
    //         Dependency::<Rc<InputNode<NumberValueI32>>>::new(Rc::clone(&a)),
    //         Dependency::<Rc<InputNode<NumberValueI32>>>::new(Rc::clone(&b)),
    //     ),
    //     Sum,
    //     NumberValueI32::default(),
    // );

    let mut visitor = HashSetVisitor::new();
    // g.resolve(&mut visitor).unwrap();
    // println!("{}", visitor.render().unwrap());
    {
        // This can fail if there are cycles in the graph or an existing read
        // reference is being held.
        let res = g.resolve_root(&mut visitor).unwrap();
        println!("Answer 1: {}", res.value);
    }
    a.update(30);
    {
        // This can fail if there are cycles in the graph or an existing read
        // reference is being held.
        let res = g.resolve_root(&mut visitor).unwrap();
        println!("Answer 2: {}", res.value);
    }

    // Product of d and e
    // let i = DerivedNode::new(
    //     Dependencies2::new(Rc::clone(&d), Rc::clone(&e)),
    //     Multiply,
    //     NumberValueI32::default(),
    // );
    // // Create another edge to node a
    // let j = DerivedNode::new(
    //     Dependencies2::new(Rc::clone(&a), Rc::clone(&i)),
    //     Sum,
    //     NumberValueI32::default(),
    // );
    //
    // // Finally, the sum of all of the above
    // let answer = DerivedNode::new(
    //     Dependencies3::new(Rc::clone(&g), Rc::clone(&h), Rc::clone(&j)),
    //     Sum,
    //     NumberValueI32::default(),
    // );
    //
    // // We can render the graph to Graphviz format
    // let mut visitor = GraphvizVisitor::new();
    // answer.resolve(&mut visitor).unwrap();
    // println!("{}", visitor.render().unwrap());
    //
    // // We can now resolve the graph. This will update all of the derived
    // // nodes
    // let mut visitor = HashSet::<usize>::new();
    // {
    //     // This can fail if there are cycles in the graph or an existing read
    //     // reference is being held.
    //     let res = answer.resolve_root(&mut visitor).unwrap();
    //     println!("Answer 1: {}", res.value);
    //     assert_eq!(res.value, (3_i32.pow(2)) + (1 + 2) + (1 + (4 * 5)));
    // }
    // {
    //     // If we update input nodes, any nodes which depend on them will be
    //     // re-resolved. Those which don't will return their cached value.
    //     a.update(10).unwrap();
    //     b.update(12).unwrap();
    //     let res = answer.resolve_root(&mut visitor).unwrap();
    //     println!("Answer 2: {}", res.value);
    //     assert_eq!(res.value, (3_i32.pow(2)) + (10 + 12) + (10 + (4 * 5)));
    // }
    // {
    //     // The graph contains multiple types whose edges are type-checked.
    //     // Therefore, only valid graphs can be constructed.
    //     c.update(5).unwrap();
    //     let res = answer.resolve_root(&mut visitor).unwrap();
    //     println!("Answer 3: {}", res.value);
    //     assert_eq!(res.value, (5_i32.pow(2)) + (10 + 12) + (10 + (4 * 5)));
    // }
}

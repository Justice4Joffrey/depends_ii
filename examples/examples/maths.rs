use std::{
    collections::HashSet,
    hash::{Hash, Hasher},
    rc::Rc,
};

use depends::{
    derives::{Dependencies, Operation, Value},
    error::EarlyExit,
    graphviz::GraphvizVisitor,
    Dependency, DerivedNode, InputNode, Resolve, SingleRef, TargetMut, UpdateDerived, UpdateInput,
    UpdateTarget,
};

/// A unit of data within a graph.
#[derive(Value, Default, Hash)]
pub struct NumberValue {
    pub value: i32,
}

impl I32Value for NumberValue {
    fn value(&self) -> i32 {
        self.value
    }
}

/// This trait allows us to connect any node which can be treated as an i32.
pub trait I32Value {
    fn value(&self) -> i32;
}

impl NumberValue {
    pub fn new(value: i32) -> Self {
        Self { value }
    }
}

// By implementing UpdateInput, we can change the value of this node from
// outside of the graph.
impl UpdateInput for NumberValue {
    type Update = i32;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

/// Another unit of data within a graph, just to demonstrate we can combine
/// arbitrary types, so long as we know how to translate the output of one to
/// the input of another.
#[derive(Value, Default, Hash)]
pub struct OtherNumberValue {
    pub value: i8,
}

impl I32Value for OtherNumberValue {
    fn value(&self) -> i32 {
        self.value as i32
    }
}

impl OtherNumberValue {
    pub fn new(value: i8) -> Self {
        Self { value }
    }
}

impl UpdateInput for OtherNumberValue {
    type Update = i8;

    fn update_mut(&mut self, update: Self::Update) {
        // Implementing this trait will provide a way for code outside of this graph to
        // change its internal state. This is just a simple replace for now.
        self.value = update;
    }
}

#[derive(Value, Default, Hash)]
pub struct Sum {
    pub value: i32,
}

impl I32Value for Sum {
    fn value(&self) -> i32 {
        self.value
    }
}

/// Any [DerivedNode] must state its dependencies. If there are more than one,
/// this must be wrapped in a struct which derived [Dependencies] as shown.
/// Otherwise, it can be passed to a [DerivedNode] wrapped with the
/// `Dependency` type.
#[derive(Dependencies)]
pub struct TwoNumbers {
    left: NumberValue,
    right: NumberValue,
}

#[derive(Dependencies)]
pub struct ThreeNumbers {
    a: NumberValue,
    b: NumberValue,
    c: NumberValue,
}

// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
// represents read-references to all of its fields.
impl<'a> UpdateTarget<TwoNumbersRef<'a>> for Sum {
    fn update_mut(
        &mut self,
        TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
    ) -> Result<(), EarlyExit> {
        self.value = left.value + right.value;
        Ok(())
    }
}

impl<'a> UpdateTarget<ThreeNumbersRef<'a>> for Sum {
    fn update_mut(
        &mut self,
        ThreeNumbersRef { a, b, c }: ThreeNumbersRef<'_>,
    ) -> Result<(), EarlyExit> {
        self.value = a.value + b.value + c.value;
        Ok(())
    }
}

#[derive(Value, Default, Hash)]
pub struct Square {
    pub value: i32,
}

impl<'a> UpdateTarget<SingleRef<'a, OtherNumberValue>> for Square {
    fn update_mut(&mut self, input: SingleRef<'_, OtherNumberValue>) -> Result<(), EarlyExit> {
        self.value = input.value.pow(2) as i32;
        Ok(())
    }
}

#[derive(Value, Default, Hash)]
pub struct Multiply {
    pub value: i32,
}

impl<'a> UpdateTarget<TwoNumbersRef<'a>> for Multiply {
    fn update_mut(
        &mut self,
        TwoNumbersRef { left, right }: TwoNumbersRef<'_>,
    ) -> Result<(), EarlyExit> {
        self.value = left.value * right.value;
        Ok(())
    }
}

// (As imported in graph.rs)
#[allow(unused)]
fn main() {
    // Create some input nodes. These are nodes we can update from outside of
    // the graph.
    let a = InputNode::new(NumberValue::new(1));
    let b = InputNode::new(NumberValue::new(2));
    // Note that we can combine different types in the same graph.
    let c = InputNode::new(OtherNumberValue::new(3));
    let d = InputNode::new(NumberValue::new(4));
    let e = InputNode::new(NumberValue::new(5));

    // Now for some derived nodes. We can't update these from outside of the
    // graph. They are updated when their dependencies change.

    // C squared
    let g = DerivedNode::new(Dependency::new(Rc::clone(&c)), Square::default());
    // Sum of a and b
    let h = DerivedNode::new(
        TwoNumbers::init(Rc::clone(&a), Rc::clone(&b)),
        Sum::default(),
    );
    // Product of d and e
    let i = DerivedNode::new(
        TwoNumbers::init(Rc::clone(&d), Rc::clone(&e)),
        Multiply::default(),
    );
    // Create another edge to node a
    let j = DerivedNode::new(
        TwoNumbers::init(Rc::clone(&a), Rc::clone(&i)),
        Sum::default(),
    );

    // Finally, the sum of all of the above
    let answer = DerivedNode::new(
        ThreeNumbers::init(Rc::clone(&g), Rc::clone(&h), Rc::clone(&j)),
        Sum::default(),
    );

    // We can render the graph to Graphviz format
    let mut visitor = GraphvizVisitor::new();
    answer.resolve(&mut visitor).unwrap();
    println!("{}", visitor.render().unwrap());

    // We can now resolve the graph. This will update all of the derived
    // nodes
    let mut visitor = HashSet::<usize>::new();
    {
        // This can fail if there are cycles in the graph or an existing read
        // reference is being held.
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 1: {}", res.value);
        assert_eq!(res.value, (3_i32.pow(2)) + (1 + 2) + (1 + (4 * 5)));
    }
    {
        // If we update input nodes, any nodes which depend on them will be
        // re-resolved. Those which don't will return their cached value.
        a.update(10).unwrap();
        b.update(12).unwrap();
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 2: {}", res.value);
        assert_eq!(res.value, (3_i32.pow(2)) + (10 + 12) + (10 + (4 * 5)));
    }
    {
        // The graph contains multiple types whose edges are type-checked.
        // Therefore, only valid graphs can be constructed.
        c.update(5).unwrap();
        let res = answer.resolve_root(&mut visitor).unwrap();
        println!("Answer 3: {}", res.value);
        assert_eq!(res.value, (5_i32.pow(2)) + (10 + 12) + (10 + (4 * 5)));
    }
}
